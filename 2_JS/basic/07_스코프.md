# 📚 7 스코프(Scope)
### 📖 스코프란
스코프(Scope) 는 영어 단어의 의미로 '영역', '범위' 라는 의미를 갖는데, JS에서의 스코프 또한 변수, 상수, 코드(=함수) 등의 접근 유효 범위를 말한다. 다르게 말하면, 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트(Execution Context)에서 접근할 수 있는 식별자들을 말한다.

### 📖 정적 스코프와 동적스코프
스코프가 동작하는 방식은 크게 2가지가 있다.   

1\) 정적 스코프(Lexical Scope): 콜 스택과 관계없이 선언 시점에 스코프를 결정하는 방식이다. 다시 말해 소스코드만 봐도 변수가 어느 스코프에 있는지 판단이 가능하다.

2\) 동적 스코프(Dynamic Scope): 런타임 도중에 실행 컨텐스트나 호출 컨텐스트에 의해 결정되는 방식이다. 쉽게 말해 함수를 호출하는 시점에서 스코프를 결정하는 방식이다.

※JS는 정적스코프의 특성을 가지고 있다.

### 📖 전역스코프, 블록스코프, 함수스코프 
JS의 정적 스코프 방식은 크게 3가지의 스코프로 나뉘어진다.

1\) 전역 스코프(Global Scope): 스코프는 계층적 구조를 가지며, 그 중에 최상위에 있는 스코프를 전역 스코프라고 한다. 프로그램을 시작할 때 바로 주어지는 스코프이다. 
최상위 계층 스코프인 전역 스코프에 선언한 변수, 상수,  함수는 어디서든 참조가 가능하다. (서로 다른 js파일에서도 접근 가능하다는 의미이다.)

※ 전역스코프를 남용하게 되면 변수, 상수, 함수 등 중복이 될 가능성이 커지며, 코드를 예측할 수 없게된다. 그렇기 때문에 IIFE를 사용하여 전역변수를 해당 파일(모듈)에서만 범위를 억제하는 방법들을 많이 사용한다.   
※ 전역 변수는 전역 스코프를 가지고 전역 객체(window)의 프로퍼티가 된다.

```js
// index.js
let global = "나는 글로벌 변수";


// page.js
console.log(global);    // "나는 글로벌 변수"
```

2\) 블록 스코프(Block Scope): 블록({}) 영역 안에서만 접근이 가능한 스코프를 블록 스코프라고 한다. ES6부터 지원하기 시작한 let, const 키워드로 선언된 변수, 함수들은 블록 스코프가 된다. 조건문, 반복문 또한 블록({})에 감싸져 있기 때문에, 해당 영역 안에서 let과 const 키워드로 선언된 변수는 블록 스코프의 규칙에 따라 접근이 가능하다.
```js
function hello(name){ 
    if(name) { 
        // let은 블록스코프 => if문 블록({}) 안에서만 접근 가능
        let greet = name + '님 안녕하세요'; 
        console.log(greet); // "Woo님 안녕하세요"
    } 
    
    console.log(greet); // ReferenceError: greet is not defined 
} 

hello('Woo');
console.log(greet); // ReferenceError: greet is not defined 
```

3\) 함수 스코프(Function Scope): 함수 영역 안에서만 접근이 가능한 스코프를 함수 스코프라고 한다. var로 선언된 변수와 함수들이 함수 스코프가 된다.

```js
function hello(name){ 
    if(name) {
        // var는 함수스코프 => 함수 안에서만 접근 가능
        var greet = name + '님 안녕하세요'; 
        console.log(greet); // "Woo님 안녕하세요"
    } 
    
    console.log(greet); // "Woo님 안녕하세요"
} 

hello('Woo');
console.log(greet); // ReferenceError: greet is not defined 

```

※ 스코프는 계층적 구조를 가지고 있으며, 하위 계층에서 상위 계층을 참조하는 것은 가능하지만, 상위 계층에서 하위 계층을 참조하는 것은 일반적으로 불가능하다.

### 📖 변수 숨김 (Variable Masking)
변수 숨김(Variable Masking)이란, let으로 선언한 변수가 가지는 성질로 내부 블록에 선언한 변수명(=식별자)과 외부 블록에 선언한 변수명이 같으면, 내부 블록에서는 내부 블록에서 선언한 변수를 우선하여 적용해주는 것을 말한다. 즉 변수명이 같을 경우 내부 변수가 외부 변수를 숨기는 효과를 말한다.

```js
{
    let x = "blue";
    console.log(x); // "blue"

    {
        let x = 3;
        console.log(x); // 3
    }
    console.log(x) // "blue"
}
console.log(x) // ReferenceError: x is not defined

```

### 📖 클로저(Closure)
클로저란 함수가 특정 스코프에 접근할 수 있도록, 스코프 안에서 함수를 정의하고 반환해주며, 반환한 함수를 통해 특정 스코프의 내부 영역에 접근이 가능하도록 만든 것을 말한다.

클로저의 장점으로는 특정 스코프에 선언한 변수나 함수 등은 특정 스코프의 상위 스코프에서 접근할 수 없으므로 정보은닉화를 할 수 있다. 또한 접근이 불가능한 스코프 영역에 접근이 가능하도록 해준다.

모든 함수를 전역에서 정의하고, 함수 안에서 전역 스코프의 변수 등을 참조하지 않도록 구성하는 방법은 전통적인 방법으로, 함수 접근이 가능한 스코프 영역을 생각할 필요가 없는 장점이 있다. 

현재에도 추천하는 방식이지만, 최신 JS에서는 함수를 변수나 객체 프로퍼티에 할당하고, 배열에 추가하고, 다른 함수에 전달하고, 함수가 함수를 반환하고, 심지어 이름 조차 없을 때가 잦아졌기 때문에 스코프 영역에 더 집중해야하고, 상황에 따라 클로저를 구성해야하는 경우가 나온다.

```js
function outterFunc() {
    let x = 10;
    let innerFunc = function () {
        console.log(x);
    }

    return innerFunc;
}

let globalFunc = outterFunc();
globalFunc();   // 10
```

### 📖 즉시 실행 함수(IIFE)
즉시 실행 함수(Immediately Invoked Function Expressions, "IFFY"라고 발음)는 함수를 선언함과 동시에 바로 실행해주는 함수이다. 

```js
// IIFE 기본 형태
(function() {
    // IIFE 내용
})();
```

IIFE의 장점은 내부에 있는 것들이 모두 private scope를 가지지만, IIFE 자체는 함수이므로, 스코프 밖으로 무언가를 return할 수 있다는 점이다. 때문에 IIFE의 스코프 안에 정의한 변수나 함수 등은 외부에서 접근할 수 없도록 안전하게 보호된다.


IIFE를 이용하여 Closure를 이용하면, 클로저를 만들 때에 priavte scope를 통해 외부 접근을 막아주며, 반환 받은 클로저를 이용하여 내부에 정의한 함수에 접근하면서도, 내부에 정의된 변수의 privacy는 계속 유지 시켜준다.

```js
const myFunc = (
    function() {
        const greeting = "Hi!";
        return function() {
            console.log(greeting);
        }
    }
)();
```

### 📖 호이스팅(Hoisting)
호이스팅은 함수 스코프를 영역으로 가지는 var로 선언한 변수와 함수들에게 일어나는 메커니즘이다. JS에서 var로 선언한 변수와 함수를 전역스코프와 함수스코프 전체를 살펴보고 속한 스코프의 최상위에 끌어다 놓는다. 참고로 선언만 끌어올려지는 것이지, 할당은 관계없다.

```js
// 원래 작성한 코드
var x = 3;
if(x === 3) {
    var x=2;
    console.log(x); // 2
}
console.log(x);     // 2
```

```js
// JS가 해석한 코드
var x;
x = 3;
if(x === 3) {
    x=2;
    console.log(x);
}
console.log(x);
```
var는 같은 변수명으로 여러번 정의하더라도 오류를 일으키지 않으며, 값을 덮어씌운다.
let의 블록스코프적 성격이 없기 때문에 변수 숨김(variable masking)도 할 수 없다. 또한 함수 선언도 스코프 맨 위로 끌어올려지기 때문에 함수의 선언 부분과 관계없이 같은 스코프에 있다면 어디서는 호출이 가능하다.

```js
// 함수 호출이 위에 있어도 함수 호이스팅 덕분에 문제 없이 실행된다.
greeting();

function greeting() {
    console.log("Hello");
}
```

### 📖 스코프 체인(Scope Chain)
스코프 체인은 스코프가 계층적 구조를 가지고 있고, 하위 계층의 스코프는 상위 계층의 스코프를 참조할 수 있는 특성에서 나온 개념이다.

스코프 체인은 먼저 자기가 속한 스코프에서 변수를 찾아보고, 없으면 상위 스코프로 접근하여 탐색을 하게 되는 관계를 말한다. 해당 스코프 내부를 먼저 탐색하고 선언된 것이 없다면, 한 단계 위의 스코프를 탐색하며 원하는 대상을 찾을 때까지 반복적으로 이루어진다. 대상을 찾거나 더이상 참조할 수 없을 때 멈추게 된다.

말 그대로 최상위 계층부터 자신이 속한 하위 계층까지 순차적으로 체인으로 묶여있는 구조다 라는 의미에서 그렇게 명명되었을지도 모른다.

### 📖 스트릭트 모드(Strict Mode)
ES5 문법에서는 암시적 전역 변수라는 것이 생길 수 있었다. 암시적 전역 변수란 var를 통해 선언한 변수가 아니면 자동으로 전역변수화가 되는 것을 말한다. 이것은 문제를 일으킬 소지가 다분했기에, JS에서는 스트릭트 모드를 도입했다.

스트릭트 모드에서는 암시적 전역 변수를 허용하지 않는다. 사용 방법은 "use strict"의 문자열을 원하는 스코프 영역의 제일 상단에 선언하면 된다. 전역 스코프에 스트릭트 모드를 적용하면 스크립트 전체의 동작 방식이 바뀌므로 주의해야한다. 최신 웹사이트는 다양한 스크립트를 불러와서 사용하므로 전역 스코프에서 스트릭트 모드를 사용하면, 불러온 스크립트 전체에 스트릭트 모드가 강제되기 때문이다. 모든 스크립트가 스트릭트 모드에서 정확히 동작한다면 좋겠지만, 어려움도 따른다. 따라서 일반적으로 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋다. 그러나 함수 하나하나마다 전부 "use strict"를 붙이고 싶은 사람은 없을 것이다. 이것을 해결하기 위해 IIFE를 이용하는 방법을 이용한다.

```js
(function() {
    "use strict";
    // 코드 내용...
})();
```
